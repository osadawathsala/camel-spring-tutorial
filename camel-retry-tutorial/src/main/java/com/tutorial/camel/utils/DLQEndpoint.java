package com.tutorial.camel.utils;

import com.tutorial.camel.config.ActiveMQConfig;
import com.tutorial.camel.processors.OnErrorLogger;
import com.tutorial.camel.processors.PrepareProcessor;
import lombok.extern.slf4j.Slf4j;
import org.apache.camel.LoggingLevel;
import org.apache.camel.builder.DeadLetterChannelBuilder;
import org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @author Osada
 * @Date 12/3/2024
 */
@Component
@Slf4j
public class DLQEndpoint {
    @Autowired
    private ActiveMQConfig config;
    public DefaultErrorHandlerDefinition dlq(String endpoint){
        return new DeadLetterChannelBuilder(endpoint)
                .useOriginalMessage()
                //custom processor right after an exception was thrown
                .onExceptionOccurred(new OnErrorLogger())
                .maximumRedeliveries(config.getMaximumRedeliveries())
               // .onRedeliver() //configure a Processor that is executed just before every redelivery attempt.
                .redeliveryDelay(config.getRedeliveryDelay())
                .useExponentialBackOff()
                .backOffMultiplier(config.getBackOffMultiplier())
                .maximumRedeliveryDelay(config.getMaximumRedeliveryDelay())
                //the log variable refers to a private static final org.slf4j.Logger field,
                // auto-generated by Lombok's @Slf4j annotation
                //stack trace of the last failed delivery
                .log(log)
                .loggingLevel(LoggingLevel.ERROR)
                .logHandled(true)
                .logExhausted(true)
                //adds a header with the exception message:
                .onPrepareFailure(new PrepareProcessor());
    }
}
